## FullTilt - Smart Leveling System for Mobile Smart Homes
## Forked from Tilty by SmartyVan — adapted for M5Stack Core1

substitutions:
  devicename: fulltilt
  upper_devicename: FullTilt

globals:
  - id: level_tolerance
    type: float
    restore_value: no
    initial_value: '1.5'

  - id: led_state
    type: int
    restore_value: no
    initial_value: '0'   # 0=off, 1=red, 2=green (test cycle)

esphome:
  name: fulltilt
  friendly_name: "Full Tilt"
  platformio_options:
    upload_speed: 460800
  on_boot:
    priority: -10
    then:
      - script.execute: keep_screen_on

esp32:
  board: m5stack-core-esp32
  framework:
    type: arduino

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: $devicename Fallback Hotspot
    password: !secret wifi_password

mdns:
captive_portal:

web_server:
  port: 80
  version: 3

logger:
  level: DEBUG
  logs:
    mpu6886: WARN
    display: ERROR
    sensor: WARN
    binary_sensor: WARN

api:

ota:
  - platform: esphome
    password: ota

spi:
  clk_pin: GPIO18
  mosi_pin: GPIO23

i2c:
  sda: 21
  scl: 22
  scan: true

# ------------------------------------------------------------
# Backlight (GPIO32)
# ------------------------------------------------------------
switch:
  - platform: gpio
    id: lcd_backlight
    name: "LCD Backlight"
    pin: 32
    restore_mode: ALWAYS_OFF

# ------------------------------------------------------------
# Side LED is a WS2812 (NeoPixel) on GPIO15
# ------------------------------------------------------------
light:
  - platform: neopixelbus
    id: side_led
    name: "Side LED"
    pin: 15
    num_leds: 1
    type: GRB
    variant: WS2812
    method: ESP32_RMT_1
    default_transition_length: 0s

# ------------------------------------------------------------
# Fonts
# ------------------------------------------------------------
font:
  - id: font_title
    file: "gfonts://Roboto Condensed"
    size: 28
  - id: font_val
    file: "gfonts://Roboto Mono"
    size: 36
  - id: font_small
    file: "gfonts://Roboto"
    size: 16

# ------------------------------------------------------------
# Display (M5STACK = ILI9342C mapping)
# ------------------------------------------------------------
display:
  - platform: ili9xxx
    model: M5STACK
    id: lcd
    cs_pin: 14
    dc_pin: 27
    reset_pin: 33
    invert_colors: true
    data_rate: 4MHz
    pixel_mode: 16bit
    color_palette: 8BIT
    auto_clear_enabled: false
    update_interval: 500ms
    transform:
      mirror_x: false     # fixes left/right mirroring
      mirror_y: False    # keep right-side-up
      swap_xy: false
    lambda: |-
      if (!id(lcd_backlight).state) return;

      // ----- Colors -----
      Color black(0, 0, 0);
      Color white(255, 255, 255);
      Color gray(100, 100, 100);
      Color light_gray(180, 180, 180);
      Color yellow(255, 255, 0);

      // ----- Clear screen -----
      it.fill(black);

      // ----- Title -----
      it.printf(160, 22, id(font_title), TextAlign::CENTER, "Full Tilt");
      it.line(20, 42, 300, 42, white);

      // ----- Numeric readouts -----
      it.printf(160, 80, id(font_small), TextAlign::CENTER, "Pitch: %.1f°", id(pitch_deg).state);
      it.printf(160, 100, id(font_small), TextAlign::CENTER, "Roll:  %.1f°", id(roll_deg).state);

      // ----- Geometry -----
      const float MAX_ANGLE = 15.0f;
      const int Cx = 160, Cy = 170;
      const int R_outer = 50;
      const int R_inner = 5;

      // Tube rim with slight 3D
      it.circle(Cx, Cy, R_outer + 2, gray);
      it.circle(Cx, Cy, R_outer, white);
      it.circle(Cx, Cy, R_outer - 2, light_gray);

      // Crosshairs
      it.line(Cx - R_outer, Cy, Cx + R_outer, Cy, gray);
      it.line(Cx, Cy - R_outer, Cx, Cy + R_outer, gray);

      // Tolerance ring
      int tol_px = int((id(level_tolerance) / MAX_ANGLE) * R_outer);
      it.circle(Cx, Cy, tol_px, yellow);

      // ----- Angles -----
      float roll  = id(roll_deg).state;
      float pitch = id(pitch_deg).state;

      // Clamp
      if (roll >  MAX_ANGLE) roll =  MAX_ANGLE;
      if (roll < -MAX_ANGLE) roll = -MAX_ANGLE;
      if (pitch >  MAX_ANGLE) pitch =  MAX_ANGLE;
      if (pitch < -MAX_ANGLE) pitch = -MAX_ANGLE;

      // ----- Deviation & gradient (GREEN -> YELLOW -> RED)
      float deviation = sqrtf(id(pitch_deg).state * id(pitch_deg).state +
                              id(roll_deg).state  * id(roll_deg).state);
      float t = deviation / id(level_tolerance);
      if (t < 0.0f) t = 0.0f;
      if (t > 2.0f) t = 2.0f;

      int r, g, b = 0;
      if (t < 1.0f) {            // 0..1 : green -> yellow
        r = int(255 * t);
        g = 255;
      } else {                   // 1..2 : yellow -> red
        r = 255;
        g = int(255 * (2.0f - t));
      }
      Color bubble_core(r, g, b);
      Color bubble_highlight(std::min(255, r + 80), std::min(255, g + 80), std::min(255, b + 80));

      // ----- Bubble position (fixed mapping)
      // Pitch controls LEFT/RIGHT (nose up -> bubble LEFT)
      // Roll  controls UP/DOWN   (roll left -> bubble UP)
      int travel = R_outer - R_inner;
      int bx = Cx - int((pitch / MAX_ANGLE) * travel);
      int by = Cy + int((roll  / MAX_ANGLE) * travel);

      // Draw shaded bubble
      it.filled_circle(bx, by, R_inner + 3, gray);               // shadow ring
      it.filled_circle(bx, by, R_inner + 2, bubble_core);        // main color
      it.filled_circle(bx - 1, by - 1, R_inner, bubble_highlight); // highlight

      // ----- Horizontal spirit bar (ROLL indicator: left/right)
      const int HB_y = 235, HB_w = 200, HB_h = 16;
      const int HB_x0 = Cx - HB_w / 2, HB_y0 = HB_y - HB_h / 2;

      it.filled_rectangle(HB_x0, HB_y0, HB_w, HB_h, gray);
      it.line(HB_x0, HB_y0, HB_x0 + HB_w, HB_y0, light_gray);
      it.line(HB_x0, HB_y0 + HB_h, HB_x0 + HB_w, HB_y0 + HB_h, black);
      it.rectangle(HB_x0, HB_y0, HB_x0 + HB_w, HB_y0 + HB_h, white);

      // Bubble moves with ROLL horizontally
      int hx_range = (HB_w / 2 - R_inner - 4);
      int hx = Cx + int((roll / MAX_ANGLE) * hx_range);
      it.filled_circle(hx, HB_y, R_inner + 2, bubble_core);
      it.filled_circle(hx - 1, HB_y - 1, R_inner, bubble_highlight);

      // ----- Vertical spirit bar (PITCH indicator: up/down)
      const int VB_x = 295, VB_h = 150, VB_w = 16;
      const int VB_y0 = Cy - VB_h / 2;

      it.filled_rectangle(VB_x - VB_w / 2, VB_y0, VB_w, VB_h, gray);
      it.line(VB_x - VB_w / 2, VB_y0, VB_x + VB_w / 2, VB_y0, light_gray);
      it.line(VB_x - VB_w / 2, VB_y0 + VB_h, VB_x + VB_w / 2, VB_y0 + VB_h, black);
      it.rectangle(VB_x - VB_w / 2, VB_y0, VB_x + VB_w / 2, VB_y0 + VB_h, white);

      // Bubble moves with PITCH vertically (nose up -> bubble up)
      int vy_range = (VB_h / 2 - R_inner - 4);
      int vy = Cy - int((pitch / MAX_ANGLE) * vy_range);
      it.filled_circle(VB_x, vy, R_inner + 2, bubble_core);
      it.filled_circle(VB_x - 1, vy - 1, R_inner, bubble_highlight);

      // ----- Status + LED (LED uses same gradient; green at level) -----
      bool level_ok = fabs(id(pitch_deg).state) < id(level_tolerance) &&
                      fabs(id(roll_deg).state)  < id(level_tolerance);
      it.printf(160, 305, id(font_title), TextAlign::CENTER,
                level_ok ? "LEVEL OK" : "OUT OF LEVEL");

      {
        auto call = id(side_led).turn_on();
        call.set_rgb(r / 255.0f, g / 255.0f, b / 255.0f);  // green near level, red far off
        call.set_brightness(1.0f);
        call.perform();
      }



# ------------------------------------------------------------
# IMU (MPU6886)
# ------------------------------------------------------------
sensor:
  - platform: mpu6886
    update_interval: 100ms
    accel_x:
      id: ax
      filters:
        - median:
            window_size: 5
            send_every: 1
      internal: true
    accel_y:
      id: ay
      filters:
        - median:
            window_size: 5
            send_every: 1
      internal: true
    accel_z:
      id: az
      filters:
        - median:
            window_size: 5
            send_every: 1
      internal: true

  - platform: template
    id: pitch_deg
    name: "Pitch"
    unit_of_measurement: "°"
    icon: "mdi:angle-acute"
    update_interval: 200ms
    accuracy_decimals: 1
    lambda: |-
      const float x = id(ax).state;
      const float y = id(ay).state;
      const float z = id(az).state;
      return atan2f(x, sqrtf(y*y + z*z)) * 57.2957795f;

  - platform: template
    id: roll_deg
    name: "Roll"
    unit_of_measurement: "°"
    icon: "mdi:angle-acute"
    update_interval: 200ms
    accuracy_decimals: 1
    lambda: |-
      const float y = id(ay).state;
      const float z = id(az).state;
      return atan2f(y, z) * 57.2957795f;

# ------------------------------------------------------------
# Button logic (A/B/C)
# ------------------------------------------------------------
binary_sensor:
  - platform: gpio
    id: btn_a
    pin:
      number: 39
      inverted: true
    name: "Button A"
    on_multi_click:
      - timing:
          - on for 50ms to 1s
        then:
          - script.execute: keep_screen_on
      - timing:
          - on for 2s to 5s
        then:
          - script.execute: cycle_leds

  - platform: gpio
    id: btn_b
    pin:
      number: 38
      inverted: true
    name: "Button B"
    on_press:
      - script.execute: keep_screen_on

  - platform: gpio
    id: btn_c
    pin:
      number: 37
      inverted: true
    name: "Button C"
    on_press:
      - script.execute: keep_screen_on

# ------------------------------------------------------------
# Scripts
# ------------------------------------------------------------
script:
  - id: keep_screen_on
    mode: restart
    then:
      - switch.turn_on: lcd_backlight
      - delay: 30s
      - switch.turn_off: lcd_backlight

  # Test LED cycle script (uses the NeoPixel)
  - id: cycle_leds
    mode: restart
    then:
      - lambda: |-
          id(led_state) += 1;
          if (id(led_state) > 2) id(led_state) = 0;

          auto call = id(side_led).turn_on();
          if (id(led_state) == 0) {
            call.set_brightness(0.0f);          // off
            ESP_LOGI("led_test", "LED OFF");
          } else if (id(led_state) == 1) {
            call.set_rgb(1.0f, 0.0f, 0.0f);     // red
            call.set_brightness(1.0f);
            ESP_LOGI("led_test", "LED RED");
          } else if (id(led_state) == 2) {
            call.set_rgb(0.0f, 1.0f, 0.0f);     // green
            call.set_brightness(1.0f);
            ESP_LOGI("led_test", "LED GREEN");
          }
          call.perform();
